#! /usr/bin/env python3

""" STM32MP Bootloader signing tool

This tool is used to sign bootloader images for STM32MP chips which support
secure boot. Keys can be generated by using:

	openssl ecparam -name prime256v1 -genkey

"""

import logging
import optparse
import sys
import struct
from Cryptodome.Hash import SHA256
from Cryptodome.PublicKey import ECC
from Cryptodome.Signature import DSS

LOG = None

def get_raw_pubkey(key):
	""" Return the binary representation of the X-Y point of the key """
	coord_x_bytes = key.pointQ.x.to_bytes().rjust(32, b'\0')
	coord_y_bytes = key.pointQ.y.to_bytes().rjust(32, b'\0')
	return coord_x_bytes + coord_y_bytes


def unpack_header(image):
	""" Decode an STM32 header into a human-readable dictionary """
	fmt = '<4s64s10I64s83xB'
	fields = struct.unpack(fmt, image[0:256])

	stm32 = {}
	stm32['magic'] = fields[0]
	stm32['signature'] = fields[1]
	stm32['checksum'] = fields[2]
	stm32['hdr_version'] = fields[3]
	stm32['length'] = fields[4]
	stm32['entry_addr'] = fields[5]
	stm32['load_addr'] = fields[7]
	stm32['hdr_version'] = fields[9]
	stm32['option_flags'] = fields[10]
	stm32['ecdsa_algo'] = fields[11]
	stm32['ecdsa_pubkey'] = fields[12]

	return stm32


def verify_signature(image, key):
	""" Verify the signature of the binary  """
	hdr = unpack_header(image)
	signature = hdr['signature']
	image_pubkey = hdr['ecdsa_pubkey']
	raw_pubkey = get_raw_pubkey(key)

	if raw_pubkey != image_pubkey:
		print('Image is not signed with the provided key')
		return 1

	sha = SHA256.new(image[0x48:])
	verifier = DSS.new(key, 'fips-186-3')

	try:
		verifier.verify(sha, signature)
		LOG.info('Signature checks out')

	except ValueError:
		LOG.error('The signature is fake news')
		LOG.error('Found:    %s', signature.hex())
		return 2

	return 0


def main():
	""" Bacon wrapper function """
	global LOG
	LOG = logging.getLogger(sys.argv[0])
	LOG.addHandler(logging.StreamHandler())
	parser = optparse.OptionParser()

	parser.add_option('-k', '--key-file', dest='key_file',
			  help='PEM file containing the ECDSA key')

	parser.add_option('-v', '--verbose', dest='verbose', action="store_true",
			  help='Output informative messages')

	parser.add_option('-d', '--debug', dest='debug', action="store_true",
			  help='Output debugging information')

	parser.add_option('-e', '--verify', dest='verify_file',
			  help='Verify signature of STM32 image')

	options, _ = parser.parse_args()

	if not options.key_file:
		parser.print_help()
		LOG.error("Must specify a key file")
		return 1

	if options.debug:
		LOG.setLevel(logging.DEBUG)
	elif options.verbose:
		LOG.setLevel('INFO')

	with open(options.key_file) as keyfile:
		key = ECC.import_key(keyfile.read())


	if options.verify_file:
		try:
			stm32_file = open(options.verify_file, 'rb')
			verify_signature(stm32_file.read(), key)
			return 0
		except OSError as err:
			LOG.error("Can't open %s", options.verify_file)
			return err.errno

	return 0


if __name__ == '__main__':
	sys.exit(main())
